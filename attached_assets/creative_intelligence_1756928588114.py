"""
Creative Intelligence System for AGI Innovation
Builds conceptual blending engine and analogical reasoning for genuine innovation
"""

import logging
import time
import threading
import numpy as np
import json
from typing import Dict, List, Any, Optional, Set, Tuple, Callable
from collections import defaultdict, deque
from datetime import datetime, timedelta
from enum import Enum
from dataclasses import dataclass, asdict
import copy
import random

logger = logging.getLogger(__name__)

class CreativityType(Enum):
    """Types of creative processes."""
    COMBINATORIAL = "combinatorial"
    EXPLORATORY = "exploratory"
    TRANSFORMATIONAL = "transformational"
    ANALOGICAL = "analogical"
    EMERGENT = "emergent"
    GENERATIVE = "generative"
    DIVERGENT = "divergent"
    CONVERGENT = "convergent"

class ConceptualSpace(Enum):
    """Types of conceptual spaces for creativity."""
    SEMANTIC = "semantic"
    VISUAL = "visual"
    AUDITORY = "auditory"
    MATHEMATICAL = "mathematical"
    LINGUISTIC = "linguistic"
    LOGICAL = "logical"
    EMOTIONAL = "emotional"
    SOCIAL = "social"

class NoveltyLevel(Enum):
    """Levels of novelty in creative outputs."""
    INCREMENTAL = "incremental"
    SUBSTANTIAL = "substantial"
    RADICAL = "radical"
    PARADIGM_SHIFTING = "paradigm_shifting"

@dataclass
class ConceptualBlend:
    """Represents a conceptual blend between concepts."""
    blend_id: str
    input_concepts: List[str]
    blended_concept: Dict[str, Any]
    mapping_relations: Dict[str, str]
    emergent_properties: List[str]
    coherence_score: float
    novelty_level: NoveltyLevel
    creativity_type: CreativityType
    creation_context: Dict[str, Any]
    timestamp: datetime
    
    def calculate_creative_value(self) -> float:
        """Calculate the creative value of this blend."""
        novelty_weights = {
            NoveltyLevel.INCREMENTAL: 0.3,
            NoveltyLevel.SUBSTANTIAL: 0.6,
            NoveltyLevel.RADICAL: 0.9,
            NoveltyLevel.PARADIGM_SHIFTING: 1.0
        }
        
        novelty_factor = novelty_weights[self.novelty_level]
        coherence_factor = self.coherence_score
        emergence_factor = len(self.emergent_properties) / 10.0
        complexity_factor = len(self.input_concepts) / 5.0
        
        return min(1.0, 0.4 * novelty_factor + 0.3 * coherence_factor + 
                   0.2 * emergence_factor + 0.1 * complexity_factor)
    
    def is_genuinely_creative(self) -> bool:
        """Check if this blend represents genuine creativity."""
        return (self.calculate_creative_value() > 0.7 and
                len(self.emergent_properties) > 2 and
                self.coherence_score > 0.6)

@dataclass
class AnalogicalMapping:
    """Represents an analogical mapping between domains."""
    mapping_id: str
    source_domain: str
    target_domain: str
    structural_mappings: Dict[str, str]
    relational_mappings: Dict[str, str]
    surface_similarities: List[str]
    deep_similarities: List[str]
    analogical_inferences: List[str]
    mapping_strength: float
    
    def calculate_analogy_quality(self) -> float:
        """Calculate the quality of this analogical mapping."""
        structural_factor = len(self.structural_mappings) / 10.0
        relational_factor = len(self.relational_mappings) / 8.0
        depth_factor = len(self.deep_similarities) / max(1, len(self.surface_similarities))
        inference_factor = len(self.analogical_inferences) / 5.0
        
        return min(1.0, 0.3 * structural_factor + 0.3 * relational_factor + 
                   0.25 * depth_factor + 0.15 * inference_factor)

@dataclass
class CreativeIdea:
    """Represents a creative idea generated by the system."""
    idea_id: str
    idea_description: str
    origin_concepts: List[str]
    creative_processes: List[CreativityType]
    conceptual_spaces: List[ConceptualSpace]
    originality_score: float
    feasibility_score: float
    value_score: float
    supporting_reasoning: List[str]
    potential_applications: List[str]
    development_path: List[str]
    
    def calculate_overall_creativity(self) -> float:
        """Calculate overall creativity score."""
        return (0.4 * self.originality_score + 
                0.3 * self.value_score + 
                0.2 * self.feasibility_score + 
                0.1 * (len(self.creative_processes) / 5.0))

class CreativeIntelligenceSystem:
    """
    System for genuine creative intelligence through conceptual blending,
    analogical reasoning, and innovative idea generation.
    """
    
    def __init__(self):
        # Core creative components
        self.conceptual_blends = {}  # blend_id -> ConceptualBlend
        self.analogical_mappings = {}  # mapping_id -> AnalogicalMapping
        self.creative_ideas = deque(maxlen=2000)
        self.concept_repository = {}  # concept_id -> concept_data
        
        # Creative engines
        self.conceptual_blending = ConceptualBlendingEngine()
        self.analogical_reasoning = AnalogicalReasoningEngine()
        self.idea_generation = IdeaGenerationEngine()
        self.novelty_detection = NoveltyDetectionEngine()
        
        # Creative processes
        self.divergent_thinking = DivergentThinkingEngine()
        self.convergent_thinking = ConvergentThinkingEngine()
        self.lateral_thinking = LateralThinkingEngine()
        self.bisociation_engine = BisociationEngine()
        
        # Creativity evaluation
        self.originality_assessor = OriginalityAssessor()
        self.value_evaluator = ValueEvaluator()
        self.feasibility_analyzer = FeasibilityAnalyzer()
        
        # Creative memory and learning
        self.creative_memory = CreativeMemorySystem()
        self.inspiration_tracker = InspirationTracker()
        self.creative_pattern_learner = CreativePatternLearner()
        
        # Creative state
        self.current_creative_focus = None
        self.active_conceptual_spaces = []
        self.creative_momentum = 0.5
        self.inspiration_sources = deque(maxlen=100)
        
        # Processing parameters
        self.creativity_threshold = 0.6
        self.blend_coherence_threshold = 0.5
        self.analogy_strength_threshold = 0.4
        self.idea_development_cycles = 5
        
        # Background processing
        self.creative_processing_enabled = True
        self.creative_generation_thread = None
        self.creative_evaluation_thread = None
        
        # Performance metrics
        self.creative_metrics = {
            'ideas_generated': 0,
            'blends_created': 0,
            'analogies_discovered': 0,
            'novel_concepts_created': 0,
            'average_creativity_score': 0.0,
            'creativity_diversity': 0.0,
            'innovation_rate': 0.0
        }
        
        self.initialized = False
        logger.info("Creative Intelligence System initialized")
    
    def initialize(self) -> bool:
        """Initialize the creative intelligence system."""
        try:
            # Initialize creative engines
            self.conceptual_blending.initialize()
            self.analogical_reasoning.initialize()
            self.idea_generation.initialize()
            self.novelty_detection.initialize()
            
            # Initialize creative processes
            self.divergent_thinking.initialize()
            self.convergent_thinking.initialize()
            self.lateral_thinking.initialize()
            self.bisociation_engine.initialize()
            
            # Initialize evaluation systems
            self.originality_assessor.initialize()
            self.value_evaluator.initialize()
            self.feasibility_analyzer.initialize()
            
            # Initialize memory and learning
            self.creative_memory.initialize()
            self.inspiration_tracker.initialize()
            self.creative_pattern_learner.initialize()
            
            # Seed concept repository
            self._seed_concept_repository()
            
            # Start creative processing
            self._start_creative_processing_threads()
            
            self.initialized = True
            logger.info("âœ… Creative Intelligence System initialized successfully")
            return True
            
        except Exception as e:
            logger.error(f"Failed to initialize creative intelligence system: {e}")
            return False
    
    def generate_conceptual_blend(self, input_concepts: List[str], 
                                context: Dict[str, Any] = None) -> Optional[str]:
        """Generate a conceptual blend from input concepts."""
        try:
            if len(input_concepts) < 2:
                return None
            
            # Validate concepts exist
            valid_concepts = [c for c in input_concepts if c in self.concept_repository]
            if len(valid_concepts) < 2:
                return None
            
            # Generate blend using conceptual blending engine
            blend_result = self.conceptual_blending.create_blend(
                valid_concepts, self.concept_repository, context or {}
            )
            
            if not blend_result or blend_result.get('coherence', 0) < self.blend_coherence_threshold:
                return None
            
            # Determine novelty level
            novelty_level = self.novelty_detection.assess_novelty_level(
                blend_result, self.conceptual_blends
            )
            
            # Create conceptual blend
            blend_id = f"blend_{int(time.time() * 1000)}"
            
            conceptual_blend = ConceptualBlend(
                blend_id=blend_id,
                input_concepts=valid_concepts,
                blended_concept=blend_result['blended_concept'],
                mapping_relations=blend_result.get('mappings', {}),
                emergent_properties=blend_result.get('emergent_properties', []),
                coherence_score=blend_result['coherence'],
                novelty_level=novelty_level,
                creativity_type=CreativityType.COMBINATORIAL,
                creation_context=context or {},
                timestamp=datetime.now()
            )
            
            self.conceptual_blends[blend_id] = conceptual_blend
            self.creative_metrics['blends_created'] += 1
            
            # Store in creative memory
            self.creative_memory.store_creative_artifact(conceptual_blend)
            
            logger.debug(f"Generated conceptual blend: {blend_id}")
            return blend_id
            
        except Exception as e:
            logger.error(f"Error generating conceptual blend: {e}")
            return None
    
    def discover_analogical_mapping(self, source_domain: str, target_domain: str,
                                  context: Dict[str, Any] = None) -> Optional[str]:
        """Discover analogical mappings between domains."""
        try:
            # Get domain representations
            source_repr = self._get_domain_representation(source_domain)
            target_repr = self._get_domain_representation(target_domain)
            
            if not source_repr or not target_repr:
                return None
            
            # Find analogical mappings
            mapping_result = self.analogical_reasoning.find_mapping(
                source_repr, target_repr, context or {}
            )
            
            if not mapping_result or mapping_result.get('strength', 0) < self.analogy_strength_threshold:
                return None
            
            # Create analogical mapping
            mapping_id = f"analogy_{int(time.time() * 1000)}"
            
            analogical_mapping = AnalogicalMapping(
                mapping_id=mapping_id,
                source_domain=source_domain,
                target_domain=target_domain,
                structural_mappings=mapping_result.get('structural', {}),
                relational_mappings=mapping_result.get('relational', {}),
                surface_similarities=mapping_result.get('surface', []),
                deep_similarities=mapping_result.get('deep', []),
                analogical_inferences=mapping_result.get('inferences', []),
                mapping_strength=mapping_result['strength']
            )
            
            self.analogical_mappings[mapping_id] = analogical_mapping
            self.creative_metrics['analogies_discovered'] += 1
            
            # Generate creative insights from analogy
            creative_insights = self._generate_insights_from_analogy(analogical_mapping)
            
            logger.debug(f"Discovered analogical mapping: {mapping_id}")
            return mapping_id
            
        except Exception as e:
            logger.error(f"Error discovering analogical mapping: {e}")
            return None
    
    def generate_creative_idea(self, inspiration_input: Dict[str, Any],
                             creative_constraints: Dict[str, Any] = None) -> Optional[str]:
        """Generate a creative idea from inspiration input."""
        try:
            # Process inspiration
            processed_inspiration = self.inspiration_tracker.process_inspiration(inspiration_input)
            
            # Apply divergent thinking
            divergent_ideas = self.divergent_thinking.generate_alternatives(
                processed_inspiration, creative_constraints or {}
            )
            
            # Apply lateral thinking for breakthrough insights
            lateral_insights = self.lateral_thinking.generate_lateral_connections(
                divergent_ideas, self.concept_repository
            )
            
            # Apply bisociation for creative connections
            bisociative_ideas = self.bisociation_engine.find_creative_intersections(
                divergent_ideas + lateral_insights
            )
            
            # Apply convergent thinking to synthesize best idea
            synthesized_idea = self.convergent_thinking.synthesize_idea(
                divergent_ideas + lateral_insights + bisociative_ideas
            )
            
            if not synthesized_idea:
                return None
            
            # Evaluate creativity dimensions
            originality = self.originality_assessor.assess_originality(
                synthesized_idea, self.creative_ideas
            )
            
            feasibility = self.feasibility_analyzer.assess_feasibility(
                synthesized_idea, creative_constraints or {}
            )
            
            value = self.value_evaluator.assess_value(
                synthesized_idea, inspiration_input
            )
            
            # Create creative idea
            idea_id = f"idea_{int(time.time() * 1000)}"
            
            creative_idea = CreativeIdea(
                idea_id=idea_id,
                idea_description=synthesized_idea['description'],
                origin_concepts=synthesized_idea.get('concepts', []),
                creative_processes=[CreativityType.DIVERGENT, CreativityType.CONVERGENT],
                conceptual_spaces=synthesized_idea.get('spaces', [ConceptualSpace.SEMANTIC]),
                originality_score=originality,
                feasibility_score=feasibility,
                value_score=value,
                supporting_reasoning=synthesized_idea.get('reasoning', []),
                potential_applications=synthesized_idea.get('applications', []),
                development_path=synthesized_idea.get('development', [])
            )
            
            # Check if genuinely creative
            if creative_idea.calculate_overall_creativity() > self.creativity_threshold:
                self.creative_ideas.append(creative_idea)
                self.creative_metrics['ideas_generated'] += 1
                
                # Update creative momentum
                self.creative_momentum = min(1.0, self.creative_momentum + 0.1)
                
                logger.debug(f"Generated creative idea: {idea_id}")
                return idea_id
            else:
                return None
            
        except Exception as e:
            logger.error(f"Error generating creative idea: {e}")
            return None
    
    def get_creative_intelligence_state(self) -> Dict[str, Any]:
        """Get comprehensive state of the creative intelligence system."""
        if not self.initialized:
            return {'error': 'Creative intelligence system not initialized'}
        
        # Update metrics
        self._update_creative_metrics()
        
        # Get recent creative outputs
        recent_ideas = [
            {
                'idea_id': idea.idea_id,
                'description': idea.idea_description[:100] + "..." if len(idea.idea_description) > 100 else idea.idea_description,
                'creativity_score': idea.calculate_overall_creativity(),
                'originality': idea.originality_score,
                'feasibility': idea.feasibility_score,
                'value': idea.value_score
            }
            for idea in list(self.creative_ideas)[-10:]
        ]
        
        # Get conceptual blends summary
        blends_summary = {
            blend_id: {
                'input_concepts': blend.input_concepts,
                'creative_value': blend.calculate_creative_value(),
                'novelty_level': blend.novelty_level.value,
                'genuinely_creative': blend.is_genuinely_creative()
            }
            for blend_id, blend in list(self.conceptual_blends.items())[-10:]
        }
        
        # Get analogical mappings summary
        analogies_summary = {
            mapping_id: {
                'source_domain': mapping.source_domain,
                'target_domain': mapping.target_domain,
                'mapping_quality': mapping.calculate_analogy_quality(),
                'inferences': len(mapping.analogical_inferences)
            }
            for mapping_id, mapping in list(self.analogical_mappings.items())[-10:]
        }
        
        return {
            'creative_momentum': self.creative_momentum,
            'current_creative_focus': self.current_creative_focus,
            'active_conceptual_spaces': [space.value for space in self.active_conceptual_spaces],
            'recent_creative_ideas': recent_ideas,
            'conceptual_blends': blends_summary,
            'analogical_mappings': analogies_summary,
            'creativity_analysis': {
                'average_creativity_score': self.creative_metrics['average_creativity_score'],
                'creativity_diversity': self.creative_metrics['creativity_diversity'],
                'innovation_rate': self.creative_metrics['innovation_rate'],
                'total_concepts': len(self.concept_repository)
            },
            'creative_processes': {
                'divergent_thinking_active': hasattr(self.divergent_thinking, 'is_active') and self.divergent_thinking.is_active(),
                'convergent_thinking_active': hasattr(self.convergent_thinking, 'is_active') and self.convergent_thinking.is_active(),
                'lateral_thinking_active': hasattr(self.lateral_thinking, 'is_active') and self.lateral_thinking.is_active(),
                'bisociation_active': hasattr(self.bisociation_engine, 'is_active') and self.bisociation_engine.is_active()
            },
            'inspiration_sources': len(self.inspiration_sources),
            'creative_metrics': self.creative_metrics,
            'timestamp': datetime.now().isoformat()
        }
    
    def _seed_concept_repository(self):
        """Seed the concept repository with initial concepts."""
        initial_concepts = [
            {'id': 'learning', 'type': 'cognitive', 'properties': ['adaptive', 'progressive', 'goal-oriented']},
            {'id': 'creativity', 'type': 'cognitive', 'properties': ['novel', 'valuable', 'intentional']},
            {'id': 'intelligence', 'type': 'cognitive', 'properties': ['problem-solving', 'adaptive', 'flexible']},
            {'id': 'consciousness', 'type': 'experiential', 'properties': ['subjective', 'unified', 'temporal']},
            {'id': 'communication', 'type': 'social', 'properties': ['interactive', 'meaningful', 'contextual']},
            {'id': 'growth', 'type': 'developmental', 'properties': ['progressive', 'transformative', 'emergent']},
            {'id': 'understanding', 'type': 'cognitive', 'properties': ['deep', 'comprehensive', 'integrated']},
            {'id': 'innovation', 'type': 'creative', 'properties': ['breakthrough', 'paradigm-shifting', 'valuable']},
            {'id': 'wisdom', 'type': 'cognitive', 'properties': ['experiential', 'practical', 'holistic']},
            {'id': 'empathy', 'type': 'emotional', 'properties': ['understanding', 'compassionate', 'perspective-taking']}
        ]
        
        for concept_data in initial_concepts:
            self.concept_repository[concept_data['id']] = concept_data
    
    def _start_creative_processing_threads(self):
        """Start background creative processing threads."""
        if self.creative_generation_thread is None or not self.creative_generation_thread.is_alive():
            self.creative_processing_enabled = True
            
            self.creative_generation_thread = threading.Thread(target=self._creative_generation_loop)
            self.creative_generation_thread.daemon = True
            self.creative_generation_thread.start()
            
            self.creative_evaluation_thread = threading.Thread(target=self._creative_evaluation_loop)
            self.creative_evaluation_thread.daemon = True
            self.creative_evaluation_thread.start()
    
    def _creative_generation_loop(self):
        """Creative generation and exploration loop."""
        while self.creative_processing_enabled:
            try:
                # Spontaneous creativity based on momentum
                if self.creative_momentum > 0.7:
                    self._generate_spontaneous_ideas()
                
                # Explore new conceptual combinations
                self._explore_conceptual_combinations()
                
                # Update creative focus
                self._update_creative_focus()
                
                time.sleep(30.0)  # Generate every 30 seconds
                
            except Exception as e:
                logger.error(f"Error in creative generation loop: {e}")
                time.sleep(60)
    
    def _creative_evaluation_loop(self):
        """Creative evaluation and learning loop."""
        while self.creative_processing_enabled:
            try:
                # Evaluate recent creative outputs
                self._evaluate_creative_outputs()
                
                # Learn creative patterns
                self.creative_pattern_learner.learn_patterns(self.creative_ideas)
                
                # Update creativity metrics
                self._update_creative_metrics()
                
                # Consolidate creative memory
                self.creative_memory.consolidate_memory()
                
                time.sleep(120.0)  # Evaluate every 2 minutes
                
            except Exception as e:
                logger.error(f"Error in creative evaluation loop: {e}")
                time.sleep(180)
    
    def cleanup(self):
        """Clean up creative intelligence system resources."""
        self.creative_processing_enabled = False
        
        if self.creative_generation_thread and self.creative_generation_thread.is_alive():
            self.creative_generation_thread.join(timeout=2)
        
        if self.creative_evaluation_thread and self.creative_evaluation_thread.is_alive():
            self.creative_evaluation_thread.join(timeout=2)
        
        logger.info("Creative Intelligence System cleaned up")

# Supporting component classes (simplified implementations)
class ConceptualBlendingEngine:
    def initialize(self): return True
    def create_blend(self, concepts, repository, context):
        return {
            'blended_concept': {'name': f"blend_of_{'_'.join(concepts)}", 'properties': []},
            'coherence': 0.7,
            'mappings': {},
            'emergent_properties': ['novelty', 'synthesis']
        }

class AnalogicalReasoningEngine:
    def initialize(self): return True
    def find_mapping(self, source, target, context):
        return {
            'strength': 0.6,
            'structural': {'element1': 'element2'},
            'relational': {'relation1': 'relation2'},
            'surface': ['similarity1'],
            'deep': ['deep_similarity1'],
            'inferences': ['inference1']
        }

class IdeaGenerationEngine:
    def initialize(self): return True

class NoveltyDetectionEngine:
    def initialize(self): return True
    def assess_novelty_level(self, blend, existing_blends):
        return NoveltyLevel.SUBSTANTIAL

class DivergentThinkingEngine:
    def initialize(self): return True
    def generate_alternatives(self, inspiration, constraints):
        return [{'description': 'Creative alternative', 'concepts': ['creativity']}]

class ConvergentThinkingEngine:
    def initialize(self): return True
    def synthesize_idea(self, ideas):
        return {
            'description': 'Synthesized creative idea',
            'concepts': ['innovation', 'creativity'],
            'reasoning': ['Based on convergent analysis'],
            'applications': ['problem solving'],
            'development': ['prototype', 'test', 'refine']
        }

class LateralThinkingEngine:
    def initialize(self): return True
    def generate_lateral_connections(self, ideas, repository):
        return [{'description': 'Lateral insight', 'concepts': ['innovation']}]

class BisociationEngine:
    def initialize(self): return True
    def find_creative_intersections(self, ideas):
        return [{'description': 'Bisociative connection', 'concepts': ['creativity']}]

class OriginalityAssessor:
    def initialize(self): return True
    def assess_originality(self, idea, existing_ideas): return 0.8

class ValueEvaluator:
    def initialize(self): return True
    def assess_value(self, idea, context): return 0.7

class FeasibilityAnalyzer:
    def initialize(self): return True
    def assess_feasibility(self, idea, constraints): return 0.6

class CreativeMemorySystem:
    def initialize(self): return True
    def store_creative_artifact(self, artifact): pass
    def consolidate_memory(self): pass

class InspirationTracker:
    def initialize(self): return True
    def process_inspiration(self, input_data): return input_data

class CreativePatternLearner:
    def initialize(self): return True
    def learn_patterns(self, ideas): pass